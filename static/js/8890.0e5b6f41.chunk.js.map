{"version":3,"file":"static/js/8890.0e5b6f41.chunk.js","mappings":"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","sources":["../node_modules/react-sortablejs/dist/src/util.ts","../node_modules/react-sortablejs/dist/src/react-sortable.tsx","../node_modules/react-sortablejs/node_modules/tiny-invariant/dist/tiny-invariant.esm.js","../node_modules/@babel/runtime/helpers/defineProperty.js","../node_modules/@babel/runtime/helpers/toPrimitive.js","../node_modules/@babel/runtime/helpers/toPropertyKey.js","../node_modules/@babel/runtime/helpers/typeof.js"],"sourcesContent":["import { PropsWithChildren } from \"react\";\nimport Sortable, { Options } from \"sortablejs\";\nimport { MultiDragEvent } from \"./react-sortable\";\nimport { AllMethodNames, ItemInterface, ReactSortableProps } from \"./types\";\n\n/**\n * Removes the `node` from the DOM\n * @param node\n */\nexport function removeNode(node: HTMLElement): void {\n  if (node.parentElement !== null) node.parentElement.removeChild(node);\n}\n\n/**\n * Inserts the `newChild` node at the given index in a parent\n * @param parent The parent HTML Element.\n * @param newChild A HTML eement to add as a child of the parent.\n * @param index index of the parent to place the new child in.\n */\nexport function insertNodeAt(\n  parent: HTMLElement,\n  newChild: HTMLElement,\n  index: number\n): void {\n  const refChild = parent.children[index] || null;\n  parent.insertBefore(newChild, refChild);\n}\n\n// @todo - create a dom handler function for arrays or not at all\n\n/** removes stuff from the dom in a nice order */\n// @todo - do I need parenElement?\nexport function handleDOMChanges<T extends ItemInterface>(\n  customs: Normalized<T>[]\n): void {\n  removeNodes(customs);\n  insertNodes(customs);\n}\n\nexport function removeNodes<T extends ItemInterface>(\n  customs: Normalized<T>[]\n): void {\n  customs.forEach((curr) => removeNode(curr.element));\n}\n\nexport function insertNodes<T extends ItemInterface>(\n  customs: Normalized<T>[]\n): void {\n  customs.forEach((curr) => {\n    insertNodeAt(curr.parentElement, curr.element, curr.oldIndex);\n  });\n}\n\nexport function createCustoms<T extends ItemInterface>(\n  evt: MultiDragEvent,\n  list: T[]\n): Normalized<T>[] {\n  const mode = getMode(evt);\n  const parentElement = { parentElement: evt.from };\n  let custom = [];\n  switch (mode) {\n    case \"normal\":\n      /* eslint-disable */\n      const item = {\n        element: evt.item,\n        newIndex: evt.newIndex!,\n        oldIndex: evt.oldIndex!,\n        parentElement: evt.from,\n      };\n      custom = [item];\n      break;\n    case \"swap\":\n      const drag: Input = {\n        element: evt.item,\n        oldIndex: evt.oldIndex!,\n        newIndex: evt.newIndex!,\n        ...parentElement,\n      };\n      const swap: Input = {\n        element: evt.swapItem!,\n        oldIndex: evt.newIndex!,\n        newIndex: evt.oldIndex!,\n        ...parentElement,\n      };\n      custom = [drag, swap];\n      break;\n    case \"multidrag\":\n      custom = evt.oldIndicies.map<Input>((curr, index) => ({\n        element: curr.multiDragElement,\n        oldIndex: curr.index,\n        newIndex: evt.newIndicies[index].index,\n        ...parentElement,\n      }));\n      break;\n  }\n  /* eslint-enable */\n\n  const customs = createNormalized(custom, list);\n  return customs;\n}\n\n/** moves items form old index to new index without breaking anything ideally. */\nexport function handleStateChanges<T extends ItemInterface>(\n  normalized: Normalized<T>[],\n  list: T[]\n): T[] {\n  const a = handleStateRemove(normalized, list);\n  const b = handleStateAdd(normalized, a);\n  return b;\n}\n\nexport function handleStateRemove<T extends ItemInterface>(\n  normalized: Normalized<T>[],\n  list: T[]\n): T[] {\n  const newList = [...list];\n  normalized\n    .concat()\n    .reverse()\n    .forEach((curr) => newList.splice(curr.oldIndex, 1));\n  return newList;\n}\n\nexport function handleStateAdd<T extends ItemInterface>(\n  normalized: Normalized<T>[],\n  list: T[],\n  evt?: Sortable.SortableEvent,\n  clone?: ((currentItem: T, evt: Sortable.SortableEvent) => T) | undefined\n): T[] {\n  const newList = [...list];\n  normalized.forEach((curr) => {\n    const newItem = clone && evt && clone(curr.item, evt);\n    newList.splice(curr.newIndex, 0, newItem || curr.item);\n  });\n  return newList;\n}\n\nexport function getMode(evt: MultiDragEvent): \"multidrag\" | \"swap\" | \"normal\" {\n  if (evt.oldIndicies && evt.oldIndicies.length > 0) return \"multidrag\";\n  if (evt.swapItem) return \"swap\";\n  return \"normal\";\n}\n\nexport function createNormalized<T extends ItemInterface>(\n  inputs: Input[],\n  list: T[]\n): Normalized<T>[] {\n  const normalized = inputs\n    .map<Normalized<T>>((curr) => ({ ...curr, item: list[curr.oldIndex] }))\n    .sort((a, b) => a.oldIndex - b.oldIndex);\n  return normalized;\n}\n\nexport interface Input {\n  parentElement: HTMLElement;\n  element: HTMLElement;\n  oldIndex: number;\n  newIndex: number;\n}\n\nexport interface Normalized<T> extends Input {\n  item: T;\n}\n\n/**\n * Removes the following group of properties from `props`,\n * leaving only `Sortable.Options` without any `on` methods.\n * @param props `ReactSortable.Props`\n */\nexport function destructurePropsForOptions<T>(\n  props: PropsWithChildren<ReactSortableProps<T>>\n): Exclude<Options, AllMethodNames> {\n  /* eslint-disable */\n  const {\n    // react sortable props\n    list,\n    setList,\n    children,\n    tag,\n    style,\n    className,\n    clone,\n    // sortable options that have methods we want to overwrite\n    onAdd,\n    onChange,\n    onChoose,\n    onClone,\n    onEnd,\n    onFilter,\n    onRemove,\n    onSort,\n    onStart,\n    onUnchoose,\n    onUpdate,\n    onMove,\n    onSpill,\n    onSelect,\n    onDeselect,\n    ...options\n  } = props;\n  /* eslint-enable */\n  return options;\n}\n\n/**\n * Construct a type with the properties of T except for those in type K.\n * Including this allows for backwards compatibility with earlier versions of TS.\n */\nexport type Omit<T, K extends keyof T> = Pick<T, Exclude<keyof T, K>>;\n","import classNames from \"classnames\";\nimport {\n  Children,\n  cloneElement,\n  Component,\n  createElement,\n  createRef,\n  ReactElement,\n  RefObject,\n} from \"react\";\nimport Sortable, { MoveEvent, Options, SortableEvent } from \"sortablejs\";\nimport invariant from \"tiny-invariant\";\nimport {\n  AllMethodsExceptMove,\n  HandledMethodNames,\n  ItemInterface,\n  ReactSortableProps,\n  Store,\n  UnHandledMethodNames,\n} from \"./types\";\nimport {\n  createCustoms,\n  destructurePropsForOptions,\n  getMode,\n  handleStateAdd,\n  handleStateChanges,\n  handleStateRemove,\n  insertNodes,\n  removeNode,\n  removeNodes,\n} from \"./util\";\n\n/** Holds a global reference for which react element is being dragged */\n// @todo - use context to manage this. How does one use 2 different providers?\nconst store: Store = { dragging: null };\n\nexport class ReactSortable<T extends ItemInterface> extends Component<\n  ReactSortableProps<T>\n> {\n  /* eslint-disable-next-line */\n  static defaultProps: Partial<ReactSortableProps<any>> = {\n    clone: (item) => item,\n  };\n\n  private ref: RefObject<HTMLElement>;\n  constructor(props: ReactSortableProps<T>) {\n    super(props);\n    // @todo forward ref this component\n    this.ref = createRef<HTMLElement>();\n\n    // make all state false because we can't change sortable unless a mouse gesture is made.\n    const newList = [...props.list].map((item) =>\n      Object.assign(item, {\n        chosen: false,\n        selected: false,\n      })\n    );\n\n    props.setList(newList, this.sortable, store);\n    invariant(\n      //@ts-expect-error: Doesn't exist. Will deprecate soon.\n      !props.plugins,\n      `\nPlugins prop is no longer supported.\nInstead, mount it with \"Sortable.mount(new MultiDrag())\"\nPlease read the updated README.md at https://github.com/SortableJS/react-sortablejs.\n      `\n    );\n  }\n\n  componentDidMount(): void {\n    if (this.ref.current === null) return;\n    const newOptions = this.makeOptions();\n    Sortable.create(this.ref.current, newOptions);\n  }\n\n  componentDidUpdate(prevProps: ReactSortableProps<T>): void {\n    if (prevProps.disabled !== this.props.disabled && this.sortable) {\n      this.sortable.option(\"disabled\", this.props.disabled);\n    }\n  }\n\n  render(): JSX.Element {\n    const { tag, style, className, id } = this.props;\n    const classicProps = { style, className, id };\n\n    // if no tag, default to a `div` element.\n    const newTag = !tag || tag === null ? \"div\" : tag;\n    return createElement(\n      newTag,\n      {\n        // @todo - find a way (perhaps with the callback) to allow AntD components to work\n        ref: this.ref,\n        ...classicProps,\n      },\n      this.getChildren()\n    );\n  }\n\n  private getChildren() {\n    const {\n      children,\n      dataIdAttr,\n      selectedClass = \"sortable-selected\",\n      chosenClass = \"sortable-chosen\",\n      /* eslint-disable */\n      dragClass = \"sortable-drag\",\n      fallbackClass = \"sortable-falback\",\n      ghostClass = \"sortable-ghost\",\n      swapClass = \"sortable-swap-highlight\",\n      /* eslint-enable */\n      filter = \"sortable-filter\",\n      list,\n    } = this.props;\n\n    // if no children, don't do anything.\n    if (!children || children == null) return null;\n    const dataid = dataIdAttr || \"data-id\";\n    /* eslint-disable-next-line */\n    return Children.map(children as ReactElement<any>[], (child, index) => {\n      if (child === undefined) return undefined;\n\n      const item = list[index] || {};\n      const { className: prevClassName } = child.props;\n\n      // @todo - handle the function if avalable. I don't think anyone will be doing this soon.\n      const filtered = typeof filter === \"string\" && {\n        [filter.replace(\".\", \"\")]: !!item.filtered,\n      };\n\n      const className = classNames(prevClassName, {\n        [selectedClass]: item.selected,\n        [chosenClass]: item.chosen,\n        ...filtered,\n        // [dragClass]: true,\n        // [fallbackClass]: true,\n        // [ghostClass]: true,\n        // [swapClass]: true\n      });\n\n      return cloneElement(child, {\n        [dataid]: child.key,\n        className,\n      });\n    });\n  }\n\n  /** Appends the `sortable` property to this component */\n  private get sortable(): Sortable | null {\n    const el = this.ref.current;\n    if (el === null) return null;\n    const key = Object.keys(el).find((k) => k.includes(\"Sortable\"));\n    if (!key) return null;\n    //@ts-expect-error: fix me.\n    return el[key] as Sortable;\n  }\n\n  /** Converts all the props from `ReactSortable` into the `options` object that `Sortable.create(el, [options])` can use. */\n  makeOptions(): Options {\n    const DOMHandlers: HandledMethodNames[] = [\n      \"onAdd\",\n      \"onChoose\",\n      \"onDeselect\",\n      \"onEnd\",\n      \"onRemove\",\n      \"onSelect\",\n      \"onSpill\",\n      \"onStart\",\n      \"onUnchoose\",\n      \"onUpdate\",\n    ];\n    const NonDOMHandlers: UnHandledMethodNames[] = [\n      \"onChange\",\n      \"onClone\",\n      \"onFilter\",\n      \"onSort\",\n    ];\n    const newOptions: Options = destructurePropsForOptions(this.props);\n    DOMHandlers.forEach(\n      (name) => (newOptions[name] = this.prepareOnHandlerPropAndDOM(name))\n    );\n    NonDOMHandlers.forEach(\n      (name) => (newOptions[name] = this.prepareOnHandlerProp(name))\n    );\n\n    /** onMove has 2 arguments and needs to be handled seperately. */\n    const onMove = (evt: MoveEvent, originalEvt: Event) => {\n      const { onMove } = this.props;\n      const defaultValue = evt.willInsertAfter || -1;\n      if (!onMove) return defaultValue;\n      const result = onMove(evt, originalEvt, this.sortable, store);\n      if (typeof result === \"undefined\") return false;\n      return result;\n    };\n\n    return {\n      ...newOptions,\n      onMove,\n    };\n  }\n\n  /** Prepares a method that will be used in the sortable options to call an `on[Handler]` prop & an `on[Handler]` ReactSortable method.  */\n  prepareOnHandlerPropAndDOM(\n    evtName: HandledMethodNames\n  ): (evt: SortableEvent) => void {\n    return (evt) => {\n      // call the component prop\n      this.callOnHandlerProp(evt, evtName);\n      // calls state change\n      //@ts-expect-error: until @types multidrag item is in\n      this[evtName](evt);\n    };\n  }\n\n  /** Prepares a method that will be used in the sortable options to call an `on[Handler]` prop */\n  prepareOnHandlerProp(\n    evtName: Exclude<AllMethodsExceptMove, HandledMethodNames>\n  ): (evt: SortableEvent) => void {\n    return (evt) => {\n      // call the component prop\n      this.callOnHandlerProp(evt, evtName);\n    };\n  }\n\n  /** Calls the `props.on[Handler]` function */\n  callOnHandlerProp(evt: SortableEvent, evtName: AllMethodsExceptMove): void {\n    const propEvent = this.props[evtName];\n    if (propEvent) propEvent(evt, this.sortable, store);\n  }\n\n  // SORTABLE DOM HANDLING\n\n  onAdd(evt: MultiDragEvent): void {\n    const { list, setList, clone } = this.props;\n    /* eslint-disable-next-line */\n    const otherList = [...store.dragging!.props.list];\n    const customs = createCustoms(evt, otherList);\n    removeNodes(customs);\n\n    const newList = handleStateAdd(customs, list, evt, clone).map((item) =>\n      Object.assign(item, {\n        selected: false,\n      })\n    );\n\n    setList(newList, this.sortable, store);\n  }\n\n  onRemove(evt: MultiDragEvent): void {\n    const { list, setList } = this.props;\n    const mode = getMode(evt);\n    const customs = createCustoms(evt, list);\n    insertNodes(customs);\n\n    let newList = [...list];\n    // remove state if not in clone mode. otherwise, keep.\n    if (evt.pullMode !== \"clone\") newList = handleStateRemove(customs, newList);\n    // if clone, it doesn't really remove. instead it clones in place.\n    // @todo -\n    else {\n      // switch used to get the clone\n      let customClones = customs;\n      switch (mode) {\n        case \"multidrag\":\n          customClones = customs.map((item, index) => ({\n            ...item,\n            element: evt.clones[index],\n          }));\n          break;\n        case \"normal\":\n          customClones = customs.map((item) => ({\n            ...item,\n            element: evt.clone,\n          }));\n          break;\n        case \"swap\":\n        default: {\n          invariant(\n            true,\n            `mode \"${mode}\" cannot clone. Please remove \"props.clone\" from <ReactSortable/> when using the \"${mode}\" plugin`\n          );\n        }\n      }\n      removeNodes(customClones);\n\n      // replace selected items with cloned items\n      customs.forEach((curr) => {\n        const index = curr.oldIndex;\n        /* eslint-disable-next-line */\n        const newItem = this.props.clone!(curr.item, evt);\n        newList.splice(index, 1, newItem);\n      });\n    }\n\n    // remove item.selected from list\n    newList = newList.map((item: T) =>\n      Object.assign(item, {\n        selected: false,\n      })\n    );\n\n    setList(newList, this.sortable, store);\n  }\n\n  onUpdate(evt: MultiDragEvent): void {\n    const { list, setList } = this.props;\n    const customs = createCustoms(evt, list);\n    removeNodes(customs);\n    insertNodes(customs);\n    const newList = handleStateChanges(customs, list);\n    return setList(newList, this.sortable, store);\n  }\n\n  onStart(): void {\n    store.dragging = this;\n  }\n\n  onEnd(): void {\n    store.dragging = null;\n  }\n\n  onChoose(evt: SortableEvent): void {\n    const { list, setList } = this.props;\n    const newList = list.map((item, index) => {\n      let newItem = item;\n      if (index === evt.oldIndex) {\n        newItem = Object.assign(item, {\n          chosen: true,\n        });\n      }\n      return newItem;\n    });\n    setList(newList, this.sortable, store);\n  }\n\n  onUnchoose(evt: SortableEvent): void {\n    const { list, setList } = this.props;\n    const newList = list.map((item, index) => {\n      let newItem = item;\n      if (index === evt.oldIndex) {\n        newItem = Object.assign(newItem, {\n          chosen: false,\n        });\n      }\n      return newItem;\n    });\n    setList(newList, this.sortable, store);\n  }\n\n  onSpill(evt: SortableEvent): void {\n    const { removeOnSpill, revertOnSpill } = this.props;\n    if (removeOnSpill && !revertOnSpill) removeNode(evt.item);\n  }\n\n  onSelect(evt: MultiDragEvent): void {\n    const { list, setList } = this.props;\n    const newList = list.map((item) =>\n      Object.assign(item, {\n        selected: false,\n      })\n    );\n\n    evt.newIndicies.forEach((curr) => {\n      const index = curr.index;\n      if (index === -1) {\n        console.log(\n          `\"${evt.type}\" had indice of \"${curr.index}\", which is probably -1 and doesn't usually happen here.`\n        );\n        console.log(evt);\n        return;\n      }\n      newList[index].selected = true;\n    });\n    setList(newList, this.sortable, store);\n  }\n\n  onDeselect(evt: MultiDragEvent): void {\n    const { list, setList } = this.props;\n    const newList = list.map((item) =>\n      Object.assign(item, {\n        selected: false,\n      })\n    );\n    evt.newIndicies.forEach((curr) => {\n      const index = curr.index;\n      if (index === -1) return;\n      newList[index].selected = true;\n    });\n    setList(newList, this.sortable, store);\n  }\n}\n\n// everything below this point can be removed\n// once @types has been merged. PR submited\ninterface MultiIndices {\n  multiDragElement: HTMLElement;\n  index: number;\n}\n\nexport interface MultiDragEvent extends SortableEvent {\n  // @todo - add this to @types\n  clones: HTMLElement[];\n  oldIndicies: MultiIndices[];\n  newIndicies: MultiIndices[];\n  swapItem: HTMLElement | null;\n}\n","var isProduction = process.env.NODE_ENV === 'production';\nvar prefix = 'Invariant failed';\nfunction invariant(condition, message) {\n    if (condition) {\n        return;\n    }\n    if (isProduction) {\n        throw new Error(prefix);\n    }\n    var provided = typeof message === 'function' ? message() : message;\n    var value = provided ? prefix + \": \" + provided : prefix;\n    throw new Error(value);\n}\n\nexport { invariant as default };\n","var toPropertyKey = require(\"./toPropertyKey.js\");\nfunction _defineProperty(obj, key, value) {\n  key = toPropertyKey(key);\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n  return obj;\n}\nmodule.exports = _defineProperty, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;","var _typeof = require(\"./typeof.js\")[\"default\"];\nfunction toPrimitive(t, r) {\n  if (\"object\" != _typeof(t) || !t) return t;\n  var e = t[Symbol.toPrimitive];\n  if (void 0 !== e) {\n    var i = e.call(t, r || \"default\");\n    if (\"object\" != _typeof(i)) return i;\n    throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n  }\n  return (\"string\" === r ? String : Number)(t);\n}\nmodule.exports = toPrimitive, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;","var _typeof = require(\"./typeof.js\")[\"default\"];\nvar toPrimitive = require(\"./toPrimitive.js\");\nfunction toPropertyKey(t) {\n  var i = toPrimitive(t, \"string\");\n  return \"symbol\" == _typeof(i) ? i : String(i);\n}\nmodule.exports = toPropertyKey, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;","function _typeof(o) {\n  \"@babel/helpers - typeof\";\n\n  return (module.exports = _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) {\n    return typeof o;\n  } : function (o) {\n    return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o;\n  }, module.exports.__esModule = true, module.exports[\"default\"] = module.exports), _typeof(o);\n}\nmodule.exports = _typeof, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;"],"names":["$eb03e74f8f7db1f3$export$1d0aa160432dfea5","node","parentElement","removeChild","$eb03e74f8f7db1f3$export$77f49a256021c8de","customs","forEach","curr","element","$eb03e74f8f7db1f3$export$a6177d5829f70ebc","parent","newChild","index","refChild","children","insertBefore","$eb03e74f8f7db1f3$export$6d240faa51aa562f","oldIndex","$eb03e74f8f7db1f3$export$4655efe700f887a","evt","list","mode","$eb03e74f8f7db1f3$export$1fc0f6205829e19c","from","custom","item","newIndex","swapItem","oldIndicies","map","multiDragElement","newIndicies","inputs","normalized","sort","a","b","$eb03e74f8f7db1f3$export$bc06a3af7dc65f53","$eb03e74f8f7db1f3$export$c25cf8080bd305ec","$eb03e74f8f7db1f3$export$eca851ee65ae17e4","$eb03e74f8f7db1f3$export$be2da95e6167b0bd","newList","concat","reverse","splice","clone","newItem","length","$eb03e74f8f7db1f3$export$7553c81e62e31b7e","props","setList","tag","style","className","onAdd","onChange","onChoose","onClone","onEnd","onFilter","onRemove","onSort","onStart","onUnchoose","onUpdate","onMove","onSpill","onSelect","onDeselect","options","$7fe8e3ea572bda7a$var$store","dragging","$7fe8e3ea572bda7a$export$11bbed9ee0012c13","$8zHUo$react","Component","constructor","super","this","ref","createRef","Object","assign","chosen","selected","sortable","$parcel$interopDefault","$8zHUo$tinyinvariant","plugins","componentDidMount","current","newOptions","makeOptions","$8zHUo$sortablejs","create","componentDidUpdate","prevProps","disabled","option","render","id","classicProps","newTag","createElement","getChildren","dataIdAttr","selectedClass","chosenClass","dragClass","fallbackClass","ghostClass","swapClass","filter","dataid","Children","child","undefined","prevClassName","filtered","replace","$8zHUo$classnames","cloneElement","key","el","keys","find","k","includes","name","prepareOnHandlerPropAndDOM","prepareOnHandlerProp","onMove1","originalEvt","defaultValue","willInsertAfter","result","evtName","callOnHandlerProp","propEvent","pullMode","customClones","clones","removeOnSpill","revertOnSpill","console","log","type","_defineProperty","isProduction","process","prefix","invariant","condition","message","Error","provided","toPropertyKey","module","exports","obj","value","defineProperty","enumerable","configurable","writable","__esModule","_typeof","t","r","e","Symbol","toPrimitive","i","call","TypeError","String","Number","o","iterator","prototype"],"sourceRoot":""}