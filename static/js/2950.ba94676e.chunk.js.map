{"version":3,"file":"static/js/2950.ba94676e.chunk.js","mappings":"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","sources":["../node_modules/@fullcalendar/premium-common/index.js","../node_modules/@fullcalendar/scrollgrid/internal.js","../node_modules/@fullcalendar/scrollgrid/index.js"],"sourcesContent":["import { createPlugin } from '@fullcalendar/core/index.js';\nimport { config, isValidDate, addDays } from '@fullcalendar/core/internal.js';\nimport { createElement, Fragment } from '@fullcalendar/core/preact.js';\n\nconst UPGRADE_WINDOW = 365 + 7; // days. 1 week leeway, for tz shift reasons too\nconst INVALID_LICENSE_URL = 'https://fullcalendar.io/docs/schedulerLicenseKey#invalid';\nconst OUTDATED_LICENSE_URL = 'https://fullcalendar.io/docs/schedulerLicenseKey#outdated';\nconst PRESET_LICENSE_KEYS = [\n    'GPL-My-Project-Is-Open-Source',\n    'CC-Attribution-NonCommercial-NoDerivatives',\n];\nconst CSS = {\n    position: 'absolute',\n    zIndex: 99999,\n    bottom: '1px',\n    left: '1px',\n    background: '#eee',\n    borderColor: '#ddd',\n    borderStyle: 'solid',\n    borderWidth: '1px 1px 0 0',\n    padding: '2px 4px',\n    fontSize: '12px',\n    borderTopRightRadius: '3px',\n};\nfunction buildLicenseWarning(context) {\n    let key = context.options.schedulerLicenseKey;\n    let currentUrl = typeof window !== 'undefined' ? window.location.href : '';\n    if (!isImmuneUrl(currentUrl)) {\n        let status = processLicenseKey(key, context.pluginHooks.premiumReleaseDate);\n        if (status !== 'valid') {\n            return (createElement(\"div\", { className: \"fc-license-message\", style: CSS }, (status === 'outdated') ? (createElement(Fragment, null,\n                'Your license key is too old to work with this version. ',\n                createElement(\"a\", { href: OUTDATED_LICENSE_URL }, \"More Info\"))) : (createElement(Fragment, null,\n                'Your license key is invalid. ',\n                createElement(\"a\", { href: INVALID_LICENSE_URL }, \"More Info\")))));\n        }\n    }\n    return null;\n}\n/*\nThis decryption is not meant to be bulletproof. Just a way to remind about an upgrade.\n*/\nfunction processLicenseKey(key, premiumReleaseDate) {\n    if (PRESET_LICENSE_KEYS.indexOf(key) !== -1) {\n        return 'valid';\n    }\n    const parts = (key || '').match(/^(\\d+)-fcs-(\\d+)$/);\n    if (parts && (parts[1].length === 10)) {\n        const purchaseDate = new Date(parseInt(parts[2], 10) * 1000);\n        const releaseDate = config.mockSchedulerReleaseDate || premiumReleaseDate;\n        if (isValidDate(releaseDate)) { // token won't be replaced in dev mode\n            const minPurchaseDate = addDays(releaseDate, -UPGRADE_WINDOW);\n            if (minPurchaseDate < purchaseDate) {\n                return 'valid';\n            }\n            return 'outdated';\n        }\n    }\n    return 'invalid';\n}\nfunction isImmuneUrl(url) {\n    return /\\w+:\\/\\/fullcalendar\\.io\\/|\\/examples\\/[\\w-]+\\.html$/.test(url);\n}\n\nconst OPTION_REFINERS = {\n    schedulerLicenseKey: String,\n};\n\nvar index = createPlugin({\n    name: '@fullcalendar/premium-common',\n    premiumReleaseDate: '2024-02-20',\n    optionRefiners: OPTION_REFINERS,\n    viewContainerAppends: [buildLicenseWarning],\n});\n\nexport { index as default };\n","import { computeEdges, removeElement, findElements, translateRect, computeInnerRect, applyStyle, BaseComponent, setRef, getIsRtlScrollbarOnLeft, Scroller, isPropsEqual, Emitter, DelayedRunner, config, memoizeArraylike, renderMicroColGroup, RefMap, getScrollGridClassNames, getCanVGrowWithinCell, getSectionClassNames, getAllowYScrolling, getSectionHasLiquidHeight, renderChunkContent, memoizeHashlike, computeShrinkWidth, getScrollbarWidths, collectFromHash, mapHash, isArraysEqual, sanitizeShrinkWidth, hasShrinkWidth, compareObjs, isColPropsEqual } from '@fullcalendar/core/internal.js';\nimport { createRef, createElement, Fragment } from '@fullcalendar/core/preact.js';\n\n// TODO: assume the el has no borders?\nfunction getScrollCanvasOrigin(scrollEl) {\n    let rect = scrollEl.getBoundingClientRect();\n    let edges = computeEdges(scrollEl); // TODO: pass in isRtl?\n    return {\n        left: rect.left + edges.borderLeft + edges.scrollbarLeft - getScrollFromLeftEdge(scrollEl),\n        top: rect.top + edges.borderTop - scrollEl.scrollTop,\n    };\n}\nfunction getScrollFromLeftEdge(el) {\n    let scrollLeft = el.scrollLeft;\n    let computedStyles = window.getComputedStyle(el); // TODO: pass in isRtl instead?\n    if (computedStyles.direction === 'rtl') {\n        switch (getRtlScrollSystem()) {\n            case 'negative':\n                scrollLeft *= -1; // convert to 'reverse'. fall through...\n            case 'reverse': // scrollLeft is distance between scrollframe's right edge scrollcanvas's right edge\n                scrollLeft = el.scrollWidth - scrollLeft - el.clientWidth;\n        }\n    }\n    return scrollLeft;\n}\nfunction setScrollFromLeftEdge(el, scrollLeft) {\n    let computedStyles = window.getComputedStyle(el); // TODO: pass in isRtl instead?\n    if (computedStyles.direction === 'rtl') {\n        switch (getRtlScrollSystem()) {\n            case 'reverse':\n                scrollLeft = el.scrollWidth - scrollLeft;\n                break;\n            case 'negative':\n                scrollLeft = -(el.scrollWidth - scrollLeft);\n                break;\n        }\n    }\n    el.scrollLeft = scrollLeft;\n}\n// Horizontal Scroll System Detection\n// ----------------------------------------------------------------------------------------------\nlet _rtlScrollSystem;\nfunction getRtlScrollSystem() {\n    return _rtlScrollSystem || (_rtlScrollSystem = detectRtlScrollSystem());\n}\nfunction detectRtlScrollSystem() {\n    let el = document.createElement('div');\n    el.style.position = 'absolute';\n    el.style.top = '-1000px';\n    el.style.width = '1px';\n    el.style.height = '1px';\n    el.style.overflow = 'scroll';\n    el.style.direction = 'rtl';\n    el.style.fontSize = '100px';\n    el.innerHTML = 'A';\n    document.body.appendChild(el);\n    let system;\n    if (el.scrollLeft > 0) {\n        system = 'positive'; // scroll is a positive number from the left edge\n    }\n    else {\n        el.scrollLeft = 1;\n        if (el.scrollLeft > 0) {\n            system = 'reverse'; // scroll is a positive number from the right edge\n        }\n        else {\n            system = 'negative'; // scroll is a negative number from the right edge\n        }\n    }\n    removeElement(el);\n    return system;\n}\n\nconst STICKY_SELECTOR = '.fc-sticky';\n/*\nGoes beyond mere position:sticky, allows horizontal centering\n\nREQUIREMENT: fc-sticky elements, if the fc-sticky className is taken away, should NOT have relative or absolute positioning.\nThis is because we attach the coords with JS, and the VDOM might take away the fc-sticky class but doesn't know kill the positioning.\n\nTODO: don't query text-align:center. isn't compatible with flexbox centering. instead, check natural X coord within parent container\n*/\nclass StickyScrolling {\n    constructor(scrollEl, isRtl) {\n        this.scrollEl = scrollEl;\n        this.isRtl = isRtl;\n        this.updateSize = () => {\n            let { scrollEl } = this;\n            let els = findElements(scrollEl, STICKY_SELECTOR);\n            let elGeoms = this.queryElGeoms(els);\n            let viewportWidth = scrollEl.clientWidth;\n            assignStickyPositions(els, elGeoms, viewportWidth);\n        };\n    }\n    queryElGeoms(els) {\n        let { scrollEl, isRtl } = this;\n        let canvasOrigin = getScrollCanvasOrigin(scrollEl);\n        let elGeoms = [];\n        for (let el of els) {\n            let parentBound = translateRect(computeInnerRect(el.parentNode, true, true), // weird way to call this!!!\n            -canvasOrigin.left, -canvasOrigin.top);\n            let elRect = el.getBoundingClientRect();\n            let computedStyles = window.getComputedStyle(el);\n            let textAlign = window.getComputedStyle(el.parentNode).textAlign; // ask the parent\n            let naturalBound = null;\n            if (textAlign === 'start') {\n                textAlign = isRtl ? 'right' : 'left';\n            }\n            else if (textAlign === 'end') {\n                textAlign = isRtl ? 'left' : 'right';\n            }\n            if (computedStyles.position !== 'sticky') {\n                naturalBound = translateRect(elRect, -canvasOrigin.left - (parseFloat(computedStyles.left) || 0), // could be 'auto'\n                -canvasOrigin.top - (parseFloat(computedStyles.top) || 0));\n            }\n            elGeoms.push({\n                parentBound,\n                naturalBound,\n                elWidth: elRect.width,\n                elHeight: elRect.height,\n                textAlign,\n            });\n        }\n        return elGeoms;\n    }\n}\nfunction assignStickyPositions(els, elGeoms, viewportWidth) {\n    els.forEach((el, i) => {\n        let { textAlign, elWidth, parentBound } = elGeoms[i];\n        let parentWidth = parentBound.right - parentBound.left;\n        let left;\n        if (textAlign === 'center' &&\n            parentWidth > viewportWidth) {\n            left = (viewportWidth - elWidth) / 2;\n        }\n        else { // if parent container can be completely in view, we don't need stickiness\n            left = '';\n        }\n        applyStyle(el, {\n            left,\n            right: left,\n            top: 0,\n        });\n    });\n}\n\nclass ClippedScroller extends BaseComponent {\n    constructor() {\n        super(...arguments);\n        this.elRef = createRef();\n        this.state = {\n            xScrollbarWidth: 0,\n            yScrollbarWidth: 0,\n        };\n        this.handleScroller = (scroller) => {\n            this.scroller = scroller;\n            setRef(this.props.scrollerRef, scroller);\n        };\n        this.handleSizing = () => {\n            let { props } = this;\n            if (props.overflowY === 'scroll-hidden') {\n                this.setState({ yScrollbarWidth: this.scroller.getYScrollbarWidth() });\n            }\n            if (props.overflowX === 'scroll-hidden') {\n                this.setState({ xScrollbarWidth: this.scroller.getXScrollbarWidth() });\n            }\n        };\n    }\n    render() {\n        let { props, state, context } = this;\n        let isScrollbarOnLeft = context.isRtl && getIsRtlScrollbarOnLeft();\n        let overcomeLeft = 0;\n        let overcomeRight = 0;\n        let overcomeBottom = 0;\n        let { overflowX, overflowY } = props;\n        if (props.forPrint) {\n            overflowX = 'visible';\n            overflowY = 'visible';\n        }\n        if (overflowX === 'scroll-hidden') {\n            overcomeBottom = state.xScrollbarWidth;\n        }\n        if (overflowY === 'scroll-hidden') {\n            if (state.yScrollbarWidth != null) {\n                if (isScrollbarOnLeft) {\n                    overcomeLeft = state.yScrollbarWidth;\n                }\n                else {\n                    overcomeRight = state.yScrollbarWidth;\n                }\n            }\n        }\n        return (createElement(\"div\", { ref: this.elRef, className: 'fc-scroller-harness' + (props.liquid ? ' fc-scroller-harness-liquid' : '') },\n            createElement(Scroller, { ref: this.handleScroller, elRef: this.props.scrollerElRef, overflowX: overflowX === 'scroll-hidden' ? 'scroll' : overflowX, overflowY: overflowY === 'scroll-hidden' ? 'scroll' : overflowY, overcomeLeft: overcomeLeft, overcomeRight: overcomeRight, overcomeBottom: overcomeBottom, maxHeight: typeof props.maxHeight === 'number'\n                    ? (props.maxHeight + (overflowX === 'scroll-hidden' ? state.xScrollbarWidth : 0))\n                    : '', liquid: props.liquid, liquidIsAbsolute: true }, props.children)));\n    }\n    componentDidMount() {\n        this.handleSizing();\n        this.context.addResizeHandler(this.handleSizing);\n    }\n    getSnapshotBeforeUpdate(prevProps) {\n        if (this.props.forPrint && !prevProps.forPrint) {\n            return { simulateScrollLeft: this.scroller.el.scrollLeft };\n        }\n        return {};\n    }\n    componentDidUpdate(prevProps, prevState, snapshot) {\n        const { props, scroller: { el: scrollerEl } } = this;\n        if (!isPropsEqual(prevProps, props)) { // an external change?\n            this.handleSizing();\n        }\n        if (snapshot.simulateScrollLeft !== undefined) {\n            scrollerEl.style.left = -snapshot.simulateScrollLeft + 'px';\n        }\n        else if (!props.forPrint && prevProps.forPrint) {\n            const restoredScrollLeft = -parseInt(scrollerEl.style.left);\n            scrollerEl.style.left = '';\n            scrollerEl.scrollLeft = restoredScrollLeft;\n        }\n    }\n    componentWillUnmount() {\n        this.context.removeResizeHandler(this.handleSizing);\n    }\n    needsXScrolling() {\n        return this.scroller.needsXScrolling();\n    }\n    needsYScrolling() {\n        return this.scroller.needsYScrolling();\n    }\n}\n\nconst WHEEL_EVENT_NAMES = 'wheel mousewheel DomMouseScroll MozMousePixelScroll'.split(' ');\n/*\nALSO, with the ability to disable touch\n*/\nclass ScrollListener {\n    constructor(el) {\n        this.el = el;\n        this.emitter = new Emitter();\n        this.isScrolling = false;\n        this.isTouching = false; // user currently has finger down?\n        this.isRecentlyWheeled = false;\n        this.isRecentlyScrolled = false;\n        this.wheelWaiter = new DelayedRunner(this._handleWheelWaited.bind(this));\n        this.scrollWaiter = new DelayedRunner(this._handleScrollWaited.bind(this));\n        // Handlers\n        // ----------------------------------------------------------------------------------------------\n        this.handleScroll = () => {\n            this.startScroll();\n            this.emitter.trigger('scroll', this.isRecentlyWheeled, this.isTouching);\n            this.isRecentlyScrolled = true;\n            this.scrollWaiter.request(500);\n        };\n        // will fire *before* the scroll event is fired (might not cause a scroll)\n        this.handleWheel = () => {\n            this.isRecentlyWheeled = true;\n            this.wheelWaiter.request(500);\n        };\n        // will fire *before* the scroll event is fired (might not cause a scroll)\n        this.handleTouchStart = () => {\n            this.isTouching = true;\n        };\n        this.handleTouchEnd = () => {\n            this.isTouching = false;\n            // if the user ended their touch, and the scroll area wasn't moving,\n            // we consider this to be the end of the scroll.\n            if (!this.isRecentlyScrolled) {\n                this.endScroll(); // won't fire if already ended\n            }\n        };\n        el.addEventListener('scroll', this.handleScroll);\n        el.addEventListener('touchstart', this.handleTouchStart, { passive: true });\n        el.addEventListener('touchend', this.handleTouchEnd);\n        for (let eventName of WHEEL_EVENT_NAMES) {\n            el.addEventListener(eventName, this.handleWheel);\n        }\n    }\n    destroy() {\n        let { el } = this;\n        el.removeEventListener('scroll', this.handleScroll);\n        el.removeEventListener('touchstart', this.handleTouchStart, { passive: true });\n        el.removeEventListener('touchend', this.handleTouchEnd);\n        for (let eventName of WHEEL_EVENT_NAMES) {\n            el.removeEventListener(eventName, this.handleWheel);\n        }\n    }\n    // Start / Stop\n    // ----------------------------------------------------------------------------------------------\n    startScroll() {\n        if (!this.isScrolling) {\n            this.isScrolling = true;\n            this.emitter.trigger('scrollStart', this.isRecentlyWheeled, this.isTouching);\n        }\n    }\n    endScroll() {\n        if (this.isScrolling) {\n            this.emitter.trigger('scrollEnd');\n            this.isScrolling = false;\n            this.isRecentlyScrolled = true;\n            this.isRecentlyWheeled = false;\n            this.scrollWaiter.clear();\n            this.wheelWaiter.clear();\n        }\n    }\n    _handleScrollWaited() {\n        this.isRecentlyScrolled = false;\n        // only end the scroll if not currently touching.\n        // if touching, the scrolling will end later, on touchend.\n        if (!this.isTouching) {\n            this.endScroll(); // won't fire if already ended\n        }\n    }\n    _handleWheelWaited() {\n        this.isRecentlyWheeled = false;\n    }\n}\n\nclass ScrollSyncer {\n    constructor(isVertical, scrollEls) {\n        this.isVertical = isVertical;\n        this.scrollEls = scrollEls;\n        this.isPaused = false;\n        this.scrollListeners = scrollEls.map((el) => this.bindScroller(el));\n    }\n    destroy() {\n        for (let scrollListener of this.scrollListeners) {\n            scrollListener.destroy();\n        }\n    }\n    bindScroller(el) {\n        let { scrollEls, isVertical } = this;\n        let scrollListener = new ScrollListener(el);\n        const onScroll = (isWheel, isTouch) => {\n            if (!this.isPaused) {\n                if (!this.masterEl || (this.masterEl !== el && (isWheel || isTouch))) {\n                    this.assignMaster(el);\n                }\n                if (this.masterEl === el) { // dealing with current\n                    for (let otherEl of scrollEls) {\n                        if (otherEl !== el) {\n                            if (isVertical) {\n                                otherEl.scrollTop = el.scrollTop;\n                            }\n                            else {\n                                otherEl.scrollLeft = el.scrollLeft;\n                            }\n                        }\n                    }\n                }\n            }\n        };\n        const onScrollEnd = () => {\n            if (this.masterEl === el) {\n                this.masterEl = null;\n            }\n        };\n        scrollListener.emitter.on('scroll', onScroll);\n        scrollListener.emitter.on('scrollEnd', onScrollEnd);\n        return scrollListener;\n    }\n    assignMaster(el) {\n        this.masterEl = el;\n        for (let scrollListener of this.scrollListeners) {\n            if (scrollListener.el !== el) {\n                scrollListener.endScroll(); // to prevent residual scrolls from reclaiming master\n            }\n        }\n    }\n    /*\n    will normalize the scrollLeft value\n    */\n    forceScrollLeft(scrollLeft) {\n        this.isPaused = true;\n        for (let listener of this.scrollListeners) {\n            setScrollFromLeftEdge(listener.el, scrollLeft);\n        }\n        this.isPaused = false;\n    }\n    forceScrollTop(top) {\n        this.isPaused = true;\n        for (let listener of this.scrollListeners) {\n            listener.el.scrollTop = top;\n        }\n        this.isPaused = false;\n    }\n}\n\nconfig.SCROLLGRID_RESIZE_INTERVAL = 500;\n/*\nTODO: make <ScrollGridSection> subcomponent\nNOTE: doesn't support collapsibleWidth (which is sortof a hack anyway)\n*/\nclass ScrollGrid extends BaseComponent {\n    constructor() {\n        super(...arguments);\n        this.compileColGroupStats = memoizeArraylike(compileColGroupStat, isColGroupStatsEqual);\n        this.renderMicroColGroups = memoizeArraylike(renderMicroColGroup); // yucky to memoize VNodes, but much more efficient for consumers\n        this.clippedScrollerRefs = new RefMap();\n        // doesn't hold non-scrolling els used just for padding\n        this.scrollerElRefs = new RefMap(this._handleScrollerEl.bind(this));\n        this.chunkElRefs = new RefMap(this._handleChunkEl.bind(this));\n        this.scrollSyncersBySection = {};\n        this.scrollSyncersByColumn = {};\n        // for row-height-syncing\n        this.rowUnstableMap = new Map(); // no need to groom. always self-cancels\n        this.rowInnerMaxHeightMap = new Map();\n        this.anyRowHeightsChanged = false;\n        this.recentSizingCnt = 0;\n        this.state = {\n            shrinkWidths: [],\n            forceYScrollbars: false,\n            forceXScrollbars: false,\n            scrollerClientWidths: {},\n            scrollerClientHeights: {},\n            sectionRowMaxHeights: [],\n        };\n        this.handleSizing = (isForcedResize, sectionRowMaxHeightsChanged) => {\n            if (!this.allowSizing()) {\n                return;\n            }\n            if (!sectionRowMaxHeightsChanged) { // something else changed, probably external\n                this.anyRowHeightsChanged = true;\n            }\n            let otherState = {};\n            // if reacting to self-change of sectionRowMaxHeightsChanged, or not stable, don't do anything\n            if (isForcedResize || (!sectionRowMaxHeightsChanged && !this.rowUnstableMap.size)) {\n                otherState.sectionRowMaxHeights = this.computeSectionRowMaxHeights();\n            }\n            this.setState(Object.assign(Object.assign({ shrinkWidths: this.computeShrinkWidths() }, this.computeScrollerDims()), otherState), () => {\n                if (!this.rowUnstableMap.size) {\n                    this.updateStickyScrolling(); // needs to happen AFTER final positioning committed to DOM\n                }\n            });\n        };\n        this.handleRowHeightChange = (rowEl, isStable) => {\n            let { rowUnstableMap, rowInnerMaxHeightMap } = this;\n            if (!isStable) {\n                rowUnstableMap.set(rowEl, true);\n            }\n            else {\n                rowUnstableMap.delete(rowEl);\n                let innerMaxHeight = getRowInnerMaxHeight(rowEl);\n                if (!rowInnerMaxHeightMap.has(rowEl) || rowInnerMaxHeightMap.get(rowEl) !== innerMaxHeight) {\n                    rowInnerMaxHeightMap.set(rowEl, innerMaxHeight);\n                    this.anyRowHeightsChanged = true;\n                }\n                if (!rowUnstableMap.size && this.anyRowHeightsChanged) {\n                    this.anyRowHeightsChanged = false;\n                    this.setState({\n                        sectionRowMaxHeights: this.computeSectionRowMaxHeights(),\n                    });\n                }\n            }\n        };\n    }\n    render() {\n        let { props, state, context } = this;\n        let { shrinkWidths } = state;\n        let colGroupStats = this.compileColGroupStats(props.colGroups.map((colGroup) => [colGroup]));\n        let microColGroupNodes = this.renderMicroColGroups(colGroupStats.map((stat, i) => [stat.cols, shrinkWidths[i]]));\n        let classNames = getScrollGridClassNames(props.liquid, context);\n        this.getDims();\n        // TODO: make DRY\n        let sectionConfigs = props.sections;\n        let configCnt = sectionConfigs.length;\n        let configI = 0;\n        let currentConfig;\n        let headSectionNodes = [];\n        let bodySectionNodes = [];\n        let footSectionNodes = [];\n        while (configI < configCnt && (currentConfig = sectionConfigs[configI]).type === 'header') {\n            headSectionNodes.push(this.renderSection(currentConfig, configI, colGroupStats, microColGroupNodes, state.sectionRowMaxHeights, true));\n            configI += 1;\n        }\n        while (configI < configCnt && (currentConfig = sectionConfigs[configI]).type === 'body') {\n            bodySectionNodes.push(this.renderSection(currentConfig, configI, colGroupStats, microColGroupNodes, state.sectionRowMaxHeights, false));\n            configI += 1;\n        }\n        while (configI < configCnt && (currentConfig = sectionConfigs[configI]).type === 'footer') {\n            footSectionNodes.push(this.renderSection(currentConfig, configI, colGroupStats, microColGroupNodes, state.sectionRowMaxHeights, true));\n            configI += 1;\n        }\n        const isBuggy = !getCanVGrowWithinCell(); // see NOTE in SimpleScrollGrid\n        const roleAttrs = { role: 'rowgroup' };\n        return createElement('table', {\n            ref: props.elRef,\n            role: 'grid',\n            className: classNames.join(' '),\n        }, renderMacroColGroup(colGroupStats, shrinkWidths), Boolean(!isBuggy && headSectionNodes.length) && createElement('thead', roleAttrs, ...headSectionNodes), Boolean(!isBuggy && bodySectionNodes.length) && createElement('tbody', roleAttrs, ...bodySectionNodes), Boolean(!isBuggy && footSectionNodes.length) && createElement('tfoot', roleAttrs, ...footSectionNodes), isBuggy && createElement('tbody', roleAttrs, ...headSectionNodes, ...bodySectionNodes, ...footSectionNodes));\n    }\n    renderSection(sectionConfig, sectionIndex, colGroupStats, microColGroupNodes, sectionRowMaxHeights, isHeader) {\n        if ('outerContent' in sectionConfig) {\n            return (createElement(Fragment, { key: sectionConfig.key }, sectionConfig.outerContent));\n        }\n        return (createElement(\"tr\", { key: sectionConfig.key, role: \"presentation\", className: getSectionClassNames(sectionConfig, this.props.liquid).join(' ') }, sectionConfig.chunks.map((chunkConfig, i) => this.renderChunk(sectionConfig, sectionIndex, colGroupStats[i], microColGroupNodes[i], chunkConfig, i, (sectionRowMaxHeights[sectionIndex] || [])[i] || [], isHeader))));\n    }\n    renderChunk(sectionConfig, sectionIndex, colGroupStat, microColGroupNode, chunkConfig, chunkIndex, rowHeights, isHeader) {\n        if ('outerContent' in chunkConfig) {\n            return (createElement(Fragment, { key: chunkConfig.key }, chunkConfig.outerContent));\n        }\n        let { state } = this;\n        let { scrollerClientWidths, scrollerClientHeights } = state;\n        let [sectionCnt, chunksPerSection] = this.getDims();\n        let index = sectionIndex * chunksPerSection + chunkIndex;\n        let sideScrollIndex = (!this.context.isRtl || getIsRtlScrollbarOnLeft()) ? chunksPerSection - 1 : 0;\n        let isVScrollSide = chunkIndex === sideScrollIndex;\n        let isLastSection = sectionIndex === sectionCnt - 1;\n        let forceXScrollbars = isLastSection && state.forceXScrollbars; // NOOOO can result in `null`\n        let forceYScrollbars = isVScrollSide && state.forceYScrollbars; // NOOOO can result in `null`\n        let allowXScrolling = colGroupStat && colGroupStat.allowXScrolling; // rename?\n        let allowYScrolling = getAllowYScrolling(this.props, sectionConfig); // rename? do in section func?\n        let chunkVGrow = getSectionHasLiquidHeight(this.props, sectionConfig); // do in section func?\n        let expandRows = sectionConfig.expandRows && chunkVGrow;\n        let tableMinWidth = (colGroupStat && colGroupStat.totalColMinWidth) || '';\n        let content = renderChunkContent(sectionConfig, chunkConfig, {\n            tableColGroupNode: microColGroupNode,\n            tableMinWidth,\n            clientWidth: scrollerClientWidths[index] !== undefined ? scrollerClientWidths[index] : null,\n            clientHeight: scrollerClientHeights[index] !== undefined ? scrollerClientHeights[index] : null,\n            expandRows,\n            syncRowHeights: Boolean(sectionConfig.syncRowHeights),\n            rowSyncHeights: rowHeights,\n            reportRowHeightChange: this.handleRowHeightChange,\n        }, isHeader);\n        let overflowX = forceXScrollbars ? (isLastSection ? 'scroll' : 'scroll-hidden') :\n            !allowXScrolling ? 'hidden' :\n                (isLastSection ? 'auto' : 'scroll-hidden');\n        let overflowY = forceYScrollbars ? (isVScrollSide ? 'scroll' : 'scroll-hidden') :\n            !allowYScrolling ? 'hidden' :\n                (isVScrollSide ? 'auto' : 'scroll-hidden');\n        // it *could* be possible to reduce DOM wrappers by only doing a ClippedScroller when allowXScrolling or allowYScrolling,\n        // but if these values were to change, the inner components would be unmounted/remounted because of the parent change.\n        content = (createElement(ClippedScroller, { ref: this.clippedScrollerRefs.createRef(index), scrollerElRef: this.scrollerElRefs.createRef(index), overflowX: overflowX, overflowY: overflowY, forPrint: this.props.forPrint, liquid: chunkVGrow, maxHeight: sectionConfig.maxHeight }, content));\n        return createElement(isHeader ? 'th' : 'td', {\n            key: chunkConfig.key,\n            ref: this.chunkElRefs.createRef(index),\n            role: 'presentation',\n        }, content);\n    }\n    componentDidMount() {\n        this.getStickyScrolling = memoizeArraylike(initStickyScrolling);\n        this.getScrollSyncersBySection = memoizeHashlike(initScrollSyncer.bind(this, true), null, destroyScrollSyncer);\n        this.getScrollSyncersByColumn = memoizeHashlike(initScrollSyncer.bind(this, false), null, destroyScrollSyncer);\n        this.updateScrollSyncers();\n        this.handleSizing(false);\n        this.context.addResizeHandler(this.handleSizing);\n    }\n    componentDidUpdate(prevProps, prevState) {\n        this.updateScrollSyncers();\n        // TODO: need better solution when state contains non-sizing things\n        this.handleSizing(false, prevState.sectionRowMaxHeights !== this.state.sectionRowMaxHeights);\n    }\n    componentWillUnmount() {\n        this.context.removeResizeHandler(this.handleSizing);\n        this.destroyScrollSyncers();\n    }\n    allowSizing() {\n        let now = new Date();\n        if (!this.lastSizingDate ||\n            now.valueOf() > this.lastSizingDate.valueOf() + config.SCROLLGRID_RESIZE_INTERVAL) {\n            this.lastSizingDate = now;\n            this.recentSizingCnt = 0;\n            return true;\n        }\n        return (this.recentSizingCnt += 1) <= 10;\n    }\n    computeShrinkWidths() {\n        let colGroupStats = this.compileColGroupStats(this.props.colGroups.map((colGroup) => [colGroup]));\n        let [sectionCnt, chunksPerSection] = this.getDims();\n        let cnt = sectionCnt * chunksPerSection;\n        let shrinkWidths = [];\n        colGroupStats.forEach((colGroupStat, i) => {\n            if (colGroupStat.hasShrinkCol) {\n                let chunkEls = this.chunkElRefs.collect(i, cnt, chunksPerSection); // in one col\n                shrinkWidths[i] = computeShrinkWidth(chunkEls);\n            }\n        });\n        return shrinkWidths;\n    }\n    // has the side effect of grooming rowInnerMaxHeightMap\n    // TODO: somehow short-circuit if there are no new height changes\n    computeSectionRowMaxHeights() {\n        let newHeightMap = new Map();\n        let [sectionCnt, chunksPerSection] = this.getDims();\n        let sectionRowMaxHeights = [];\n        for (let sectionI = 0; sectionI < sectionCnt; sectionI += 1) {\n            let sectionConfig = this.props.sections[sectionI];\n            let assignableHeights = []; // chunk, row\n            if (sectionConfig && sectionConfig.syncRowHeights) {\n                let rowHeightsByChunk = [];\n                for (let chunkI = 0; chunkI < chunksPerSection; chunkI += 1) {\n                    let index = sectionI * chunksPerSection + chunkI;\n                    let rowHeights = [];\n                    let chunkEl = this.chunkElRefs.currentMap[index];\n                    if (chunkEl) {\n                        rowHeights = findElements(chunkEl, '.fc-scrollgrid-sync-table tr').map((rowEl) => {\n                            let max = getRowInnerMaxHeight(rowEl);\n                            newHeightMap.set(rowEl, max);\n                            return max;\n                        });\n                    }\n                    else {\n                        rowHeights = [];\n                    }\n                    rowHeightsByChunk.push(rowHeights);\n                }\n                let rowCnt = rowHeightsByChunk[0].length;\n                let isEqualRowCnt = true;\n                for (let chunkI = 1; chunkI < chunksPerSection; chunkI += 1) {\n                    let isOuterContent = sectionConfig.chunks[chunkI] && sectionConfig.chunks[chunkI].outerContent !== undefined; // can be null\n                    if (!isOuterContent && rowHeightsByChunk[chunkI].length !== rowCnt) { // skip outer content\n                        isEqualRowCnt = false;\n                        break;\n                    }\n                }\n                if (!isEqualRowCnt) {\n                    let chunkHeightSums = [];\n                    for (let chunkI = 0; chunkI < chunksPerSection; chunkI += 1) {\n                        chunkHeightSums.push(sumNumbers(rowHeightsByChunk[chunkI]) + rowHeightsByChunk[chunkI].length);\n                    }\n                    let maxTotalSum = Math.max(...chunkHeightSums);\n                    for (let chunkI = 0; chunkI < chunksPerSection; chunkI += 1) {\n                        let rowInChunkCnt = rowHeightsByChunk[chunkI].length;\n                        let rowInChunkTotalHeight = maxTotalSum - rowInChunkCnt; // subtract border\n                        // height of non-first row. we do this to avoid rounding, because it's unreliable within a table\n                        let rowInChunkHeightOthers = Math.floor(rowInChunkTotalHeight / rowInChunkCnt);\n                        // whatever is leftover goes to the first row\n                        let rowInChunkHeightFirst = rowInChunkTotalHeight - rowInChunkHeightOthers * (rowInChunkCnt - 1);\n                        let rowInChunkHeights = [];\n                        let row = 0;\n                        if (row < rowInChunkCnt) {\n                            rowInChunkHeights.push(rowInChunkHeightFirst);\n                            row += 1;\n                        }\n                        while (row < rowInChunkCnt) {\n                            rowInChunkHeights.push(rowInChunkHeightOthers);\n                            row += 1;\n                        }\n                        assignableHeights.push(rowInChunkHeights);\n                    }\n                }\n                else {\n                    for (let chunkI = 0; chunkI < chunksPerSection; chunkI += 1) {\n                        assignableHeights.push([]);\n                    }\n                    for (let row = 0; row < rowCnt; row += 1) {\n                        let rowHeightsAcrossChunks = [];\n                        for (let chunkI = 0; chunkI < chunksPerSection; chunkI += 1) {\n                            let h = rowHeightsByChunk[chunkI][row];\n                            if (h != null) { // protect against outerContent\n                                rowHeightsAcrossChunks.push(h);\n                            }\n                        }\n                        let maxHeight = Math.max(...rowHeightsAcrossChunks);\n                        for (let chunkI = 0; chunkI < chunksPerSection; chunkI += 1) {\n                            assignableHeights[chunkI].push(maxHeight);\n                        }\n                    }\n                }\n            }\n            sectionRowMaxHeights.push(assignableHeights);\n        }\n        this.rowInnerMaxHeightMap = newHeightMap;\n        return sectionRowMaxHeights;\n    }\n    computeScrollerDims() {\n        let scrollbarWidth = getScrollbarWidths();\n        let [sectionCnt, chunksPerSection] = this.getDims();\n        let sideScrollI = (!this.context.isRtl || getIsRtlScrollbarOnLeft()) ? chunksPerSection - 1 : 0;\n        let lastSectionI = sectionCnt - 1;\n        let currentScrollers = this.clippedScrollerRefs.currentMap;\n        let scrollerEls = this.scrollerElRefs.currentMap;\n        let forceYScrollbars = false;\n        let forceXScrollbars = false;\n        let scrollerClientWidths = {};\n        let scrollerClientHeights = {};\n        for (let sectionI = 0; sectionI < sectionCnt; sectionI += 1) { // along edge\n            let index = sectionI * chunksPerSection + sideScrollI;\n            let scroller = currentScrollers[index];\n            if (scroller && scroller.needsYScrolling()) {\n                forceYScrollbars = true;\n                break;\n            }\n        }\n        for (let chunkI = 0; chunkI < chunksPerSection; chunkI += 1) { // along last row\n            let index = lastSectionI * chunksPerSection + chunkI;\n            let scroller = currentScrollers[index];\n            if (scroller && scroller.needsXScrolling()) {\n                forceXScrollbars = true;\n                break;\n            }\n        }\n        for (let sectionI = 0; sectionI < sectionCnt; sectionI += 1) {\n            for (let chunkI = 0; chunkI < chunksPerSection; chunkI += 1) {\n                let index = sectionI * chunksPerSection + chunkI;\n                let scrollerEl = scrollerEls[index];\n                if (scrollerEl) {\n                    // TODO: weird way to get this. need harness b/c doesn't include table borders\n                    let harnessEl = scrollerEl.parentNode;\n                    scrollerClientWidths[index] = Math.floor(harnessEl.getBoundingClientRect().width - ((chunkI === sideScrollI && forceYScrollbars)\n                        ? scrollbarWidth.y // use global because scroller might not have scrollbars yet but will need them in future\n                        : 0));\n                    scrollerClientHeights[index] = Math.floor(harnessEl.getBoundingClientRect().height - ((sectionI === lastSectionI && forceXScrollbars)\n                        ? scrollbarWidth.x // use global because scroller might not have scrollbars yet but will need them in future\n                        : 0));\n                }\n            }\n        }\n        return { forceYScrollbars, forceXScrollbars, scrollerClientWidths, scrollerClientHeights };\n    }\n    updateStickyScrolling() {\n        let { isRtl } = this.context;\n        let argsByKey = this.scrollerElRefs.getAll().map((scrollEl) => [scrollEl, isRtl]);\n        this.getStickyScrolling(argsByKey)\n            .forEach((stickyScrolling) => stickyScrolling.updateSize());\n    }\n    updateScrollSyncers() {\n        let [sectionCnt, chunksPerSection] = this.getDims();\n        let cnt = sectionCnt * chunksPerSection;\n        let scrollElsBySection = {};\n        let scrollElsByColumn = {};\n        let scrollElMap = this.scrollerElRefs.currentMap;\n        for (let sectionI = 0; sectionI < sectionCnt; sectionI += 1) {\n            let startIndex = sectionI * chunksPerSection;\n            let endIndex = startIndex + chunksPerSection;\n            scrollElsBySection[sectionI] = collectFromHash(scrollElMap, startIndex, endIndex, 1); // use the filtered\n        }\n        for (let col = 0; col < chunksPerSection; col += 1) {\n            scrollElsByColumn[col] = this.scrollerElRefs.collect(col, cnt, chunksPerSection); // DON'T use the filtered\n        }\n        this.scrollSyncersBySection = this.getScrollSyncersBySection(scrollElsBySection);\n        this.scrollSyncersByColumn = this.getScrollSyncersByColumn(scrollElsByColumn);\n    }\n    destroyScrollSyncers() {\n        mapHash(this.scrollSyncersBySection, destroyScrollSyncer);\n        mapHash(this.scrollSyncersByColumn, destroyScrollSyncer);\n    }\n    getChunkConfigByIndex(index) {\n        let chunksPerSection = this.getDims()[1];\n        let sectionI = Math.floor(index / chunksPerSection);\n        let chunkI = index % chunksPerSection;\n        let sectionConfig = this.props.sections[sectionI];\n        return sectionConfig && sectionConfig.chunks[chunkI];\n    }\n    forceScrollLeft(col, scrollLeft) {\n        let scrollSyncer = this.scrollSyncersByColumn[col];\n        if (scrollSyncer) {\n            scrollSyncer.forceScrollLeft(scrollLeft);\n        }\n    }\n    forceScrollTop(sectionI, scrollTop) {\n        let scrollSyncer = this.scrollSyncersBySection[sectionI];\n        if (scrollSyncer) {\n            scrollSyncer.forceScrollTop(scrollTop);\n        }\n    }\n    _handleChunkEl(chunkEl, key) {\n        let chunkConfig = this.getChunkConfigByIndex(parseInt(key, 10));\n        if (chunkConfig) { // null if section disappeared. bad, b/c won't null-set the elRef\n            setRef(chunkConfig.elRef, chunkEl);\n        }\n    }\n    _handleScrollerEl(scrollerEl, key) {\n        let chunkConfig = this.getChunkConfigByIndex(parseInt(key, 10));\n        if (chunkConfig) { // null if section disappeared. bad, b/c won't null-set the elRef\n            setRef(chunkConfig.scrollerElRef, scrollerEl);\n        }\n    }\n    getDims() {\n        let sectionCnt = this.props.sections.length;\n        let chunksPerSection = sectionCnt ? this.props.sections[0].chunks.length : 0;\n        return [sectionCnt, chunksPerSection];\n    }\n}\nScrollGrid.addStateEquality({\n    shrinkWidths: isArraysEqual,\n    scrollerClientWidths: isPropsEqual,\n    scrollerClientHeights: isPropsEqual,\n});\nfunction sumNumbers(numbers) {\n    let sum = 0;\n    for (let n of numbers) {\n        sum += n;\n    }\n    return sum;\n}\nfunction getRowInnerMaxHeight(rowEl) {\n    let innerHeights = findElements(rowEl, '.fc-scrollgrid-sync-inner').map(getElHeight);\n    if (innerHeights.length) {\n        return Math.max(...innerHeights);\n    }\n    return 0;\n}\nfunction getElHeight(el) {\n    return el.offsetHeight; // better to deal with integers, for rounding, for PureComponent\n}\nfunction renderMacroColGroup(colGroupStats, shrinkWidths) {\n    let children = colGroupStats.map((colGroupStat, i) => {\n        let width = colGroupStat.width;\n        if (width === 'shrink') {\n            width = colGroupStat.totalColWidth + sanitizeShrinkWidth(shrinkWidths[i]) + 1; // +1 for border :(\n        }\n        return ( // eslint-disable-next-line react/jsx-key\n        createElement(\"col\", { style: { width } }));\n    });\n    return createElement('colgroup', {}, ...children);\n}\nfunction compileColGroupStat(colGroupConfig) {\n    let totalColWidth = sumColProp(colGroupConfig.cols, 'width'); // excludes \"shrink\"\n    let totalColMinWidth = sumColProp(colGroupConfig.cols, 'minWidth');\n    let hasShrinkCol = hasShrinkWidth(colGroupConfig.cols);\n    let allowXScrolling = colGroupConfig.width !== 'shrink' && Boolean(totalColWidth || totalColMinWidth || hasShrinkCol);\n    return {\n        hasShrinkCol,\n        totalColWidth,\n        totalColMinWidth,\n        allowXScrolling,\n        cols: colGroupConfig.cols,\n        width: colGroupConfig.width,\n    };\n}\nfunction sumColProp(cols, propName) {\n    let total = 0;\n    for (let col of cols) {\n        let val = col[propName];\n        if (typeof val === 'number') {\n            total += val * (col.span || 1);\n        }\n    }\n    return total;\n}\nconst COL_GROUP_STAT_EQUALITY = {\n    cols: isColPropsEqual,\n};\nfunction isColGroupStatsEqual(stat0, stat1) {\n    return compareObjs(stat0, stat1, COL_GROUP_STAT_EQUALITY);\n}\n// for memoizers...\nfunction initScrollSyncer(isVertical, ...scrollEls) {\n    return new ScrollSyncer(isVertical, scrollEls);\n}\nfunction destroyScrollSyncer(scrollSyncer) {\n    scrollSyncer.destroy();\n}\nfunction initStickyScrolling(scrollEl, isRtl) {\n    return new StickyScrolling(scrollEl, isRtl);\n}\n\nexport { ScrollGrid };\n","import { createPlugin } from '@fullcalendar/core/index.js';\nimport premiumCommonPlugin from '@fullcalendar/premium-common/index.js';\nimport { ScrollGrid } from './internal.js';\nimport '@fullcalendar/core/internal.js';\nimport '@fullcalendar/core/preact.js';\n\nvar index = createPlugin({\n    name: '@fullcalendar/scrollgrid',\n    premiumReleaseDate: '2024-02-20',\n    deps: [premiumCommonPlugin],\n    scrollGridImpl: ScrollGrid,\n});\n\nexport { index as default };\n"],"names":["UPGRADE_WINDOW","PRESET_LICENSE_KEYS","CSS","position","zIndex","bottom","left","background","borderColor","borderStyle","borderWidth","padding","fontSize","borderTopRightRadius","OPTION_REFINERS","schedulerLicenseKey","String","index","createPlugin","name","premiumReleaseDate","optionRefiners","viewContainerAppends","context","key","options","currentUrl","window","location","href","test","status","indexOf","parts","match","length","purchaseDate","Date","parseInt","releaseDate","config","mockSchedulerReleaseDate","isValidDate","addDays","processLicenseKey","pluginHooks","createElement","className","style","Fragment","getScrollFromLeftEdge","el","scrollLeft","getComputedStyle","direction","getRtlScrollSystem","scrollWidth","clientWidth","setScrollFromLeftEdge","_rtlScrollSystem","system","document","top","width","height","overflow","innerHTML","body","appendChild","removeElement","detectRtlScrollSystem","StickyScrolling","constructor","scrollEl","isRtl","this","updateSize","els","findElements","elGeoms","viewportWidth","forEach","i","textAlign","elWidth","parentBound","parentWidth","right","applyStyle","assignStickyPositions","queryElGeoms","canvasOrigin","rect","getBoundingClientRect","edges","computeEdges","borderLeft","scrollbarLeft","borderTop","scrollTop","getScrollCanvasOrigin","translateRect","computeInnerRect","parentNode","elRect","computedStyles","naturalBound","parseFloat","push","elHeight","ClippedScroller","BaseComponent","super","arguments","elRef","createRef","state","xScrollbarWidth","yScrollbarWidth","handleScroller","scroller","setRef","props","scrollerRef","handleSizing","overflowY","setState","getYScrollbarWidth","overflowX","getXScrollbarWidth","render","isScrollbarOnLeft","getIsRtlScrollbarOnLeft","overcomeLeft","overcomeRight","overcomeBottom","forPrint","ref","liquid","Scroller","scrollerElRef","maxHeight","liquidIsAbsolute","children","componentDidMount","addResizeHandler","getSnapshotBeforeUpdate","prevProps","simulateScrollLeft","componentDidUpdate","prevState","snapshot","scrollerEl","isPropsEqual","undefined","restoredScrollLeft","componentWillUnmount","removeResizeHandler","needsXScrolling","needsYScrolling","WHEEL_EVENT_NAMES","split","ScrollListener","emitter","Emitter","isScrolling","isTouching","isRecentlyWheeled","isRecentlyScrolled","wheelWaiter","DelayedRunner","_handleWheelWaited","bind","scrollWaiter","_handleScrollWaited","handleScroll","startScroll","trigger","request","handleWheel","handleTouchStart","handleTouchEnd","endScroll","addEventListener","passive","eventName","destroy","removeEventListener","clear","ScrollSyncer","isVertical","scrollEls","isPaused","scrollListeners","map","bindScroller","scrollListener","on","onScroll","isWheel","isTouch","masterEl","assignMaster","otherEl","onScrollEnd","forceScrollLeft","listener","forceScrollTop","SCROLLGRID_RESIZE_INTERVAL","ScrollGrid","compileColGroupStats","memoizeArraylike","compileColGroupStat","isColGroupStatsEqual","renderMicroColGroups","renderMicroColGroup","clippedScrollerRefs","RefMap","scrollerElRefs","_handleScrollerEl","chunkElRefs","_handleChunkEl","scrollSyncersBySection","scrollSyncersByColumn","rowUnstableMap","Map","rowInnerMaxHeightMap","anyRowHeightsChanged","recentSizingCnt","shrinkWidths","forceYScrollbars","forceXScrollbars","scrollerClientWidths","scrollerClientHeights","sectionRowMaxHeights","isForcedResize","sectionRowMaxHeightsChanged","allowSizing","otherState","size","computeSectionRowMaxHeights","Object","assign","computeShrinkWidths","computeScrollerDims","updateStickyScrolling","handleRowHeightChange","rowEl","isStable","delete","innerMaxHeight","getRowInnerMaxHeight","has","get","set","colGroupStats","colGroups","colGroup","microColGroupNodes","stat","cols","classNames","getScrollGridClassNames","getDims","currentConfig","sectionConfigs","sections","configCnt","configI","headSectionNodes","bodySectionNodes","footSectionNodes","type","renderSection","isBuggy","getCanVGrowWithinCell","roleAttrs","role","join","colGroupStat","totalColWidth","sanitizeShrinkWidth","renderMacroColGroup","Boolean","sectionConfig","sectionIndex","isHeader","outerContent","getSectionClassNames","chunks","chunkConfig","renderChunk","microColGroupNode","chunkIndex","rowHeights","sectionCnt","chunksPerSection","isVScrollSide","isLastSection","allowXScrolling","allowYScrolling","getAllowYScrolling","chunkVGrow","getSectionHasLiquidHeight","expandRows","tableMinWidth","totalColMinWidth","content","renderChunkContent","tableColGroupNode","clientHeight","syncRowHeights","rowSyncHeights","reportRowHeightChange","getStickyScrolling","initStickyScrolling","getScrollSyncersBySection","memoizeHashlike","initScrollSyncer","destroyScrollSyncer","getScrollSyncersByColumn","updateScrollSyncers","destroyScrollSyncers","now","lastSizingDate","valueOf","cnt","hasShrinkCol","chunkEls","collect","computeShrinkWidth","newHeightMap","sectionI","assignableHeights","rowHeightsByChunk","chunkI","chunkEl","currentMap","max","rowCnt","isEqualRowCnt","row","rowHeightsAcrossChunks","h","Math","chunkHeightSums","sumNumbers","maxTotalSum","rowInChunkCnt","rowInChunkTotalHeight","rowInChunkHeightOthers","floor","rowInChunkHeightFirst","rowInChunkHeights","scrollbarWidth","getScrollbarWidths","sideScrollI","lastSectionI","currentScrollers","scrollerEls","harnessEl","y","x","argsByKey","getAll","stickyScrolling","scrollElsBySection","scrollElsByColumn","scrollElMap","startIndex","endIndex","collectFromHash","col","mapHash","getChunkConfigByIndex","scrollSyncer","numbers","sum","n","innerHeights","getElHeight","offsetHeight","colGroupConfig","sumColProp","hasShrinkWidth","propName","total","val","span","addStateEquality","isArraysEqual","COL_GROUP_STAT_EQUALITY","isColPropsEqual","stat0","stat1","compareObjs","_len","Array","_key","deps","premiumCommonPlugin","scrollGridImpl"],"sourceRoot":""}